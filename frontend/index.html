<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AstroGuide</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <script>
      // Check if user data exists
      const userData = localStorage.getItem("userData");
      if (!userData) {
        window.location.href = "landing.html";
      }
    </script>

    <div class="chat-container">
      <div class="chat-header">
        <h1>AstroGuide</h1>
        <button id="logout-button" class="logout-button">Logout</button>
        <button id="clear-button" class="clear-button">Clear Chat</button>
        <button id="recalculate-chart-button" class="recalculate-button">
          Recalculate Chart
        </button>
        <button id="view-raw-data-button" class="view-raw-button">
          View Raw Data
        </button>
      </div>
      <div class="chat-messages" id="chat-messages">
        <div class="message bot-message initial-message">
          Hello! I'm AstroGuide, your astrological guide. I'm here to help you
          understand yourself through your birth chart. What would you like to
          explore?
        </div>
      </div>
      <div class="input-container">
        <input
          type="text"
          id="message-input"
          placeholder="Type your message here..."
        />
        <button id="send-button">Send</button>
      </div>
    </div>

    <style>
      body {
        background: #23243a;
        color: #f5f6fa;
      }
      .chat-container {
        background: #18192b;
        border-radius: 12px;
        box-shadow: 0 2px 16px rgba(0, 0, 0, 0.3);
        padding: 24px;
      }
      .chat-header h1 {
        color: #fff;
      }
      .message {
        margin: 10px;
        padding: 12px 16px;
        border-radius: 8px;
        max-width: 80%;
        word-wrap: break-word;
        font-size: 1.08em;
      }
      .bot-message {
        background-color: #2d2e48;
        color: #f5f6fa;
        margin-right: auto;
        border: 1px solid #35365a;
        white-space: pre-wrap;
      }
      .initial-message {
        white-space: normal;
      }
      .user-message {
        background-color: #3b82f6;
        color: #fff;
        margin-left: auto;
        border: 1px solid #2563eb;
      }
      .input-container {
        display: flex;
        margin-top: 16px;
      }
      #message-input {
        flex: 1;
        padding: 10px 14px;
        border-radius: 6px;
        border: none;
        background: #23243a;
        color: #f5f6fa;
        font-size: 1em;
        margin-right: 8px;
      }
      #message-input::placeholder {
        color: #888ca3;
      }
      #send-button {
        background: #3b82f6;
        color: #fff;
        border: none;
        border-radius: 6px;
        padding: 10px 18px;
        font-size: 1em;
        cursor: pointer;
        transition: background 0.2s;
      }
      #send-button:hover {
        background: #2563eb;
      }
      .logout-button {
        background: #e74c3c;
        color: #fff;
        border: none;
        border-radius: 6px;
        padding: 8px 16px;
        margin-left: 10px;
        cursor: pointer;
        transition: background 0.2s;
      }
      .logout-button:hover {
        background: #c0392b;
      }
      .clear-button {
        padding: 8px 16px;
        background: #6366f1;
        border: none;
        border-radius: 6px;
        color: #fff;
        cursor: pointer;
        transition: background 0.3s ease;
        margin-left: 10px;
      }
      .clear-button:hover {
        background: #4338ca;
      }
      .recalculate-button {
        padding: 8px 16px;
        background: #f59e0b;
        border: none;
        border-radius: 6px;
        color: #fff;
        cursor: pointer;
        transition: background 0.3s ease;
        margin-left: 10px;
      }
      .recalculate-button:hover {
        background: #d97706;
      }
      .view-raw-button {
        padding: 8px 16px;
        background: #10b981;
        border: none;
        border-radius: 6px;
        color: #fff;
        cursor: pointer;
        transition: background 0.3s ease;
        margin-left: 10px;
      }
      .view-raw-button:hover {
        background: #059669;
      }
      .raw-data-display {
        background: #1a1a2e;
        border: 1px solid #35365a;
        border-radius: 8px;
        padding: 16px;
        margin: 10px;
        max-height: 500px;
        overflow-y: auto;
        font-family: "Courier New", monospace;
        font-size: 12px;
        white-space: pre-wrap;
        word-wrap: break-word;
      }
      .spinner-container {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px;
        min-height: 50px;
        position: relative;
      }
      .spinner {
        width: 30px;
        height: 30px;
        margin: 10px;
        border: 3px solid #35365a;
        border-top: 3px solid #3b82f6;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        display: block;
      }
      .typing-indicator {
        display: inline-block;
        padding: 10px;
        color: #b3b6d4;
        font-style: italic;
        min-width: 150px;
        text-align: left;
      }
      .typing-indicator::after {
        content: "...";
        display: inline-block;
        width: 24px;
        text-align: left;
        animation: typing 1.5s infinite;
      }
      @keyframes typing {
        0% {
          content: ".";
        }
        33% {
          content: "..";
        }
        66% {
          content: "...";
        }
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Animation for bot messages */
      .bot-message.fade-in {
        opacity: 0;
        transform: translateX(-20px);
        transition: opacity 3s ease-out, transform 3s ease-out;
      }

      .bot-message.fade-in.animate {
        opacity: 1;
        transform: translateX(0);
      }
    </style>

    <script>
      const messageInput = document.getElementById("message-input");
      const sendButton = document.getElementById("send-button");
      const chatMessages = document.getElementById("chat-messages");
      const logoutButton = document.getElementById("logout-button");
      const clearButton = document.getElementById("clear-button");
      const recalculateChartButton = document.getElementById(
        "recalculate-chart-button"
      );
      const viewRawDataButton = document.getElementById("view-raw-data-button");

      // Message queue for bot messages
      const botMessageQueue = [];
      let isTyping = false;

      // Queue-based addMessage for bot messages
      function queueBotMessage(message) {
        console.log("[QUEUE] Adding bot message to queue:", message);
        return new Promise((resolve) => {
          botMessageQueue.push({ message, resolve });
          // Always try to process the queue, even if already typing
          setTimeout(processBotQueue, 0);
        });
      }

      async function processBotQueue() {
        if (isTyping || botMessageQueue.length === 0) return;
        isTyping = true;
        const { message, resolve } = botMessageQueue.shift();
        console.log("[QUEUE] Processing bot message:", message);
        await addMessage(message, false, true); // true = from queue
        isTyping = false;
        resolve();
        // Always try to process the queue again in case new messages were added
        setTimeout(processBotQueue, 0);
      }

      // Modified addMessage to support queue
      function addMessage(message, isUser = false, fromQueue = false) {
        return new Promise((resolve) => {
          const messageDiv = document.createElement("div");
          messageDiv.className = `message ${
            isUser ? "user-message" : "bot-message"
          }`;

          if (isUser) {
            console.log("[MESSAGE] Adding user message:", message);
            messageDiv.textContent = message;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            resolve();
          } else {
            // For bot messages, use typewriter effect only if from queue
            hideSpinner();
            messageDiv.classList.add("typing");
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            if (fromQueue) {
              console.log(
                "[TYPEWRITER] Starting typewriter for bot message:",
                message
              );
              typeMessage(messageDiv, message, 30, () => {
                console.log(
                  "[TYPEWRITER] Finished typing bot message:",
                  message
                );
                resolve();
              });
            } else {
              // If not from queue, type instantly (for compatibility)
              messageDiv.textContent = message;
              messageDiv.classList.remove("typing");
              resolve();
            }
          }
        });
      }

      // Updated typeMessage to create a left-to-right sweeping fade-in animation
      function typeMessage(element, message, speed = 30, done) {
        // Set the full message content
        element.textContent = message;

        // Add the fade-in class
        element.classList.add("fade-in");

        // Trigger the animation after a small delay
        setTimeout(() => {
          element.classList.add("animate");
        }, 50);

        // Remove typing class and call done callback after animation
        setTimeout(() => {
          element.classList.remove("typing", "fade-in", "animate");
          if (done) done();
        }, 3000);
      }

      async function handleSendMessage() {
        const message = messageInput.value.trim();
        if (message) {
          console.log("[HANDLE] User sent message:", message);
          await addMessage(message, true);
          messageInput.value = "";

          // Get user data from localStorage
          const userData = JSON.parse(localStorage.getItem("userData"));

          if (!userData) {
            await queueBotMessage(
              "Error: No user data found. Please log in or create an account first."
            );
            return;
          }

          // Check if birth chart data exists, if not, fetch it automatically
          let birthChartData = JSON.parse(
            localStorage.getItem("birthChartData")
          );

          if (!birthChartData) {
            // Automatically fetch birth chart on first message
            const loadingMessage = "Let me take a look at your birth chart...";
            await queueBotMessage(loadingMessage);
            console.log("[SPINNER] Showing spinner after loading message");
            showSpinner();

            // Parse birth date and time directly from strings
            const [year, month, day] = userData.birthDate
              .split("-")
              .map(Number);
            const [hours, minutes] = userData.birthTime.split(":").map(Number);

            // Function to get coordinates from city name with better error handling
            async function getCoordinates(cityName) {
              if (!cityName || cityName.trim() === "") {
                throw new Error("Birth place is required");
              }

              try {
                // Use a more specific query format for better results
                const query = encodeURIComponent(cityName.trim());
                const response = await fetch(
                  `https://nominatim.openstreetmap.org/search?format=json&q=${query}&limit=1&addressdetails=1`,
                  {
                    headers: {
                      "User-Agent": "AstroGuide/1.0", // Required by Nominatim
                    },
                  }
                );

                if (!response.ok) {
                  throw new Error(
                    `Geocoding service error: ${response.status}`
                  );
                }

                const data = await response.json();

                if (!data || data.length === 0) {
                  throw new Error(
                    `Location "${cityName}" not found. Please check the spelling and try a more specific location (e.g., "City, State, Country").`
                  );
                }

                const result = data[0];
                const latitude = parseFloat(result.lat);
                const longitude = parseFloat(result.lon);

                // Validate coordinates are valid numbers
                if (isNaN(latitude) || isNaN(longitude)) {
                  throw new Error(
                    "Invalid coordinates returned from geocoding service"
                  );
                }

                // Validate coordinates are within valid ranges
                if (
                  latitude < -90 ||
                  latitude > 90 ||
                  longitude < -180 ||
                  longitude > 180
                ) {
                  throw new Error("Coordinates out of valid range");
                }

                // Get the display name for verification
                const displayName = result.display_name || cityName;

                console.log(`[GEOCODING] Resolved "${cityName}" to:`, {
                  displayName: displayName,
                  latitude: latitude,
                  longitude: longitude,
                  type: result.type,
                  importance: result.importance,
                });

                return {
                  latitude: latitude,
                  longitude: longitude,
                  displayName: displayName,
                  originalQuery: cityName,
                };
              } catch (error) {
                console.error("[GEOCODING] Error getting coordinates:", error);
                // Don't silently default - throw the error so user knows
                throw error;
              }
            }

            // Get coordinates from birth place with validation
            const birthPlace = userData.birthPlace;

            if (!birthPlace || birthPlace.trim() === "") {
              await queueBotMessage(
                "Error: Birth place is required. Please update your profile with your birth location."
              );
              return;
            }

            let coordinates;
            let resolvedLocation;

            try {
              coordinates = await getCoordinates(birthPlace);
              resolvedLocation = coordinates.displayName;

              // Verify the resolved location matches (or warn if it's different)
              if (
                coordinates.originalQuery.toLowerCase() !==
                coordinates.displayName.toLowerCase()
              ) {
                console.warn(
                  `[GEOCODING] Location resolved to different name: "${coordinates.displayName}" from "${birthPlace}"`
                );
                // Show a message to the user about the resolved location
                await queueBotMessage(
                  `Note: I've resolved your birth place "${birthPlace}" to "${coordinates.displayName}". If this is incorrect, please update your birth location in your profile.`
                );
              }
            } catch (error) {
              await queueBotMessage(
                `Error: Could not find coordinates for "${birthPlace}". ${error.message} Please update your birth location with a more specific format (e.g., "City, State, Country" or "City, Country").`
              );
              return;
            }

            // Calculate timezone from coordinates and date
            // Simplified version that worked before - US-focused with proper boundaries and DST
            async function calculateTimezone(lat, lon, y, m, d) {
              // Base offset from longitude (rough estimate: 15 degrees = 1 hour)
              let baseOffset = Math.round(lon / 15);

              // US timezone adjustments (most accurate for US locations)
              // These boundaries match what worked previously - NO latitude restriction
              // Note: Timezone boundaries don't follow longitude exactly
              // Tucson, AZ is at ~-110.9Â° and should be Mountain Time (UTC-7)
              if (lon >= -125 && lon < -67) {
                // Pacific Time: West Coast (approximately -125 to -112)
                if (lon >= -125 && lon < -112) {
                  baseOffset = -8; // Pacific Time
                }
                // Mountain Time: Mountain states (approximately -112 to -102)
                // This includes Arizona (Tucson at -110.9Â°), New Mexico, Colorado, etc.
                else if (lon >= -112 && lon < -102) {
                  baseOffset = -7; // Mountain Time
                }
                // Central Time: Central states (approximately -102 to -87)
                else if (lon >= -102 && lon < -87) {
                  baseOffset = -6; // Central Time
                }
                // Eastern Time: East Coast (approximately -87 to -67)
                else if (lon >= -87 && lon < -67) {
                  baseOffset = -5; // Eastern Time
                }

                // Check for Daylight Saving Time (US)
                // IMPORTANT: Arizona and Hawaii do NOT observe DST
                const month = m;
                const day = d;

                // Check if location is in Arizona (no DST)
                // Arizona roughly: lat 31-37, lon -115 to -109
                const isArizona =
                  lat >= 31 && lat <= 37 && lon >= -115 && lon < -109;

                // Check if location is in Hawaii (no DST)
                // Hawaii roughly: lat 18-23, lon -161 to -154
                const isHawaii =
                  lat >= 18 && lat <= 23 && lon >= -161 && lon < -154;

                // Only apply DST if NOT in Arizona or Hawaii
                if (!isArizona && !isHawaii) {
                  // DST since 2007: Second Sunday March to First Sunday November
                  if (y >= 2007) {
                    const marchStart = getNthSunday(y, 3, 2);
                    const novEnd = getNthSunday(y, 11, 1);
                    const dateNum = y * 10000 + month * 100 + day;
                    const startNum = y * 10000 + 3 * 100 + marchStart;
                    const endNum = y * 10000 + 11 * 100 + novEnd;

                    if (dateNum >= startNum && dateNum < endNum) {
                      baseOffset += 1; // DST
                    }
                  } else if (y >= 1987) {
                    // 1987-2006: First Sunday April to Last Sunday October
                    const aprilStart = getNthSunday(y, 4, 1);
                    const octEnd = getLastSunday(y, 10);
                    const dateNum = y * 10000 + month * 100 + day;
                    const startNum = y * 10000 + 4 * 100 + aprilStart;
                    const endNum = y * 10000 + 10 * 100 + octEnd;

                    if (dateNum >= startNum && dateNum <= endNum) {
                      baseOffset += 1; // DST
                    }
                  }
                } else {
                  // Arizona and Hawaii don't observe DST - always stay at base offset
                  console.log(
                    `[TIMEZONE] Location is in ${
                      isArizona ? "Arizona" : "Hawaii"
                    } - no DST applied`
                  );
                }
              }

              // Enhanced logging with clear timezone display
              const timezoneInfo = {
                timezone: baseOffset,
                display:
                  baseOffset >= 0 ? `UTC+${baseOffset}` : `UTC${baseOffset}`,
                coordinates: `(${lat.toFixed(4)}, ${lon.toFixed(4)})`,
                date: `${y}-${m}-${d}`,
                isArizona: lat >= 31 && lat <= 37 && lon >= -115 && lon < -109,
                isHawaii: lat >= 18 && lat <= 23 && lon >= -161 && lon < -154,
              };

              console.log(
                "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              );
              console.log("ðŸŒ TIMEZONE CALCULATION RESULT");
              console.log(
                "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              );
              console.log(`ðŸ“ Location: ${timezoneInfo.coordinates}`);
              console.log(`ðŸ“… Date: ${timezoneInfo.date}`);
              console.log(
                `â° Timezone: ${timezoneInfo.display} (${baseOffset} hours from UTC)`
              );
              if (timezoneInfo.isArizona) {
                console.log(
                  `âš ï¸  Arizona detected - NO DST applied (always UTC-7)`
                );
              } else if (timezoneInfo.isHawaii) {
                console.log(
                  `âš ï¸  Hawaii detected - NO DST applied (always UTC-10)`
                );
              }
              console.log(
                "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              );

              return baseOffset;
            }

            function getNthSunday(year, month, n) {
              const firstDay = new Date(year, month - 1, 1);
              const firstSunday = 1 + ((7 - firstDay.getDay()) % 7);
              return firstSunday + (n - 1) * 7;
            }

            function getLastSunday(year, month) {
              const lastDay = new Date(year, month, 0);
              const dayOfWeek = lastDay.getDay();
              return lastDay.getDate() - dayOfWeek;
            }

            const approximateTimezone = await calculateTimezone(
              coordinates.latitude,
              coordinates.longitude,
              year,
              month,
              day
            );

            // Format timezone for display (e.g., "UTC-5" or "UTC+5.5")
            const timezoneDisplay =
              approximateTimezone >= 0
                ? `UTC+${approximateTimezone}`
                : `UTC${approximateTimezone}`;

            const requestData = {
              year: year,
              month: month,
              day: day,
              hour: hours,
              minute: minutes,
              latitude: coordinates.latitude,
              longitude: coordinates.longitude,
              timezone: approximateTimezone, // Timezone offset in hours
            };

            // Detailed logging for debugging ascendant issues
            console.log("=== BIRTH CHART CALCULATION DEBUG ===");
            console.log("Original Input:", {
              birthPlace: birthPlace,
              birthDate: userData.birthDate,
              birthTime: userData.birthTime,
            });
            console.log("Resolved Location:", {
              displayName: resolvedLocation,
              latitude: coordinates.latitude,
              longitude: coordinates.longitude,
            });
            console.log("Parsed Date/Time:", {
              year: year,
              month: month,
              day: day,
              hour: hours,
              minute: minutes,
            });
            const isUSLocation =
              coordinates.longitude >= -125 && coordinates.longitude < -67;
            console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            console.log("ðŸ“Š BIRTH CHART REQUEST SUMMARY");
            console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            console.log("ðŸ“ Location:", {
              original: birthPlace,
              resolved: resolvedLocation,
              coordinates: `${coordinates.latitude.toFixed(
                4
              )}Â°N, ${coordinates.longitude.toFixed(4)}Â°E`,
            });
            console.log("ðŸ“… Date/Time:", {
              date: `${year}-${month}-${day}`,
              time: `${hours}:${String(minutes).padStart(2, "0")}`,
            });
            console.log("â° TIMEZONE:", {
              offset: approximateTimezone,
              display: timezoneDisplay,
              isUSLocation: isUSLocation,
              note: isUSLocation
                ? "Using US timezone boundaries"
                : "Using longitude approximation (may be inaccurate)",
            });
            console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            console.log("Final Request Data:", requestData);
            console.log("=====================================");

            // Show user the calculated timezone for verification
            const arizonaNote =
              coordinates.latitude >= 31 &&
              coordinates.latitude <= 37 &&
              coordinates.longitude >= -115 &&
              coordinates.longitude < -109
                ? " (Arizona - no DST)"
                : "";
            await queueBotMessage(
              `Calculating chart for ${resolvedLocation} (${coordinates.latitude.toFixed(
                4
              )}Â°N, ${coordinates.longitude.toFixed(
                4
              )}Â°E)\n\nâ° Timezone: ${timezoneDisplay}${arizonaNote}\n\nIf this timezone is incorrect, the ascendant may be wrong. Check the browser console (F12) for detailed timezone information.`
            );

            // Additional validation logging
            console.log("[VALIDATION] Birth chart request validation:", {
              dateValid:
                year > 1900 &&
                year < 2100 &&
                month >= 1 &&
                month <= 12 &&
                day >= 1 &&
                day <= 31,
              timeValid:
                hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60,
              coordinatesValid:
                coordinates.latitude >= -90 &&
                coordinates.latitude <= 90 &&
                coordinates.longitude >= -180 &&
                coordinates.longitude <= 180,
              timezoneValid:
                approximateTimezone >= -12 && approximateTimezone <= 14,
            });

            try {
              // Make API call to backend
              console.log("[API] Requesting birth chart:", requestData);
              const response = await fetch(
                "http://localhost:3000/api/birth-chart",
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                  },
                  body: JSON.stringify(requestData),
                }
              );
              console.log("[API] Fetch to /api/birth-chart sent");

              if (!response.ok) {
                const err = await response.json();
                console.error(
                  "[API] Error response from /api/birth-chart:",
                  err
                );
                throw new Error(
                  err.details || err.error || "Failed to calculate birth chart"
                );
              }

              const data = await response.json();
              console.log("[API] Received birth chart data:", data);
              console.log(
                "[API] Raw birth chart data structure:",
                JSON.stringify(data, null, 2)
              );

              // Store the birth chart data in localStorage for follow-up questions
              localStorage.setItem("birthChartData", JSON.stringify(data));
              birthChartData = data;

              // Birth chart loaded successfully
              // Show a brief confirmation with location verification
              const locationInfo = `Using location: ${resolvedLocation} (${coordinates.latitude.toFixed(
                4
              )}Â°N, ${coordinates.longitude.toFixed(4)}Â°E)`;
              console.log("[API] Birth chart calculated with:", locationInfo);

              await queueBotMessage(
                `I've calculated your birth chart using ${resolvedLocation}! Let me answer your question...`
              );
            } catch (error) {
              console.error(
                "[ERROR] Exception in /api/birth-chart flow:",
                error
              );
              let errorMessage =
                "I'm having trouble calculating your birth chart right now.";

              if (error.message) {
                errorMessage = error.message;
              } else if (error.details) {
                errorMessage = error.details;
              }

              await queueBotMessage(`Error: ${errorMessage}`);
              return; // Stop if birth chart couldn't be loaded
            } finally {
              console.log("[SPINNER] Hiding spinner after birth chart flow");
              hideSpinner();
            }

            // After loading birth chart successfully, continue to process the user's message below
            // (birthChartData is now set, so it will fall through to the chat handling)
          }

          // Handle questions about the birth chart
          // (birthChartData is either already loaded or was just loaded above)
          if (birthChartData) {
            console.log("[SPINNER] Showing spinner for chat follow-up");
            showSpinner();
            // Get conversation history from localStorage
            let conversationHistory = JSON.parse(
              localStorage.getItem("conversationHistory") || "[]"
            );

            // Add the user's message to the conversation history
            conversationHistory.push({
              role: "user",
              content: message,
            });

            try {
              // Send the question along with the birth chart data and conversation history to the backend
              console.log("[API] Sending chat follow-up:", {
                message,
                birthChart: birthChartData,
                conversationHistory,
              });
              const response = await fetch("http://localhost:3000/api/chat", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  message: message,
                  birthChart: birthChartData,
                  conversationHistory: conversationHistory,
                }),
              });

              const data = await response.json();
              console.log("[API] Received chat response:", data);
              console.log(
                "[API] Raw chat response:",
                JSON.stringify(data, null, 2)
              );

              // Add the bot's response to the conversation history
              conversationHistory.push({
                role: "assistant",
                content: data.response,
              });

              // Keep only the last 10 messages to maintain context without overwhelming
              if (conversationHistory.length > 10) {
                conversationHistory = conversationHistory.slice(-10);
              }

              // Save the updated conversation history
              localStorage.setItem(
                "conversationHistory",
                JSON.stringify(conversationHistory)
              );

              // Display the response with typewriter effect
              await queueBotMessage(data.response);
            } catch (error) {
              console.error("Error:", error);
              await queueBotMessage(
                "I'm having trouble processing your question right now. Could you try rephrasing it?"
              );
            } finally {
              console.log("[SPINNER] Hiding spinner after chat follow-up");
              hideSpinner();
            }
          } else {
            // This shouldn't happen since we fetch it automatically above,
            // but just in case there was an error
            await queueBotMessage(
              "I'm having trouble accessing your birth chart data. Please try refreshing the page."
            );
          }
        }
      }

      // Add a function to clear conversation history
      function clearConversationHistory() {
        localStorage.removeItem("conversationHistory");
        addMessage(
          "Conversation history cleared. Feel free to start a new conversation!"
        );
      }

      // Add a function to test the backend connection
      function testBackendConnection() {
        fetch("http://localhost:3000/api/test")
          .then((response) => response.json())
          .then((data) => {
            console.log("Backend test response:", data);
          })
          .catch((error) => {
            console.error("Backend connection test failed:", error);
          });
      }

      // Test backend connection when page loads
      testBackendConnection();

      // Logout handler
      logoutButton.addEventListener("click", () => {
        // Clear all stored data
        localStorage.clear();
        // Redirect to landing page
        window.location.href = "landing.html";
      });

      sendButton.addEventListener("click", handleSendMessage);
      messageInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          handleSendMessage();
        }
      });

      // Recalculate chart button handler - clears cached data and forces recalculation
      recalculateChartButton.addEventListener("click", async () => {
        // Clear the cached birth chart data
        localStorage.removeItem("birthChartData");
        localStorage.removeItem("conversationHistory");

        await queueBotMessage(
          "I've cleared your cached birth chart data. Please send a message to recalculate your chart with the correct location."
        );
      });

      // View raw data button handler
      viewRawDataButton.addEventListener("click", () => {
        const birthChartData = JSON.parse(
          localStorage.getItem("birthChartData") || "null"
        );

        if (!birthChartData) {
          alert(
            "No birth chart data available. Please send a message first to load your birth chart."
          );
          return;
        }

        // Check if raw data display already exists
        let rawDataDiv = document.getElementById("raw-data-display");

        if (rawDataDiv) {
          // Toggle visibility
          if (rawDataDiv.style.display === "none") {
            rawDataDiv.style.display = "block";
            viewRawDataButton.textContent = "Hide Raw Data";
          } else {
            rawDataDiv.style.display = "none";
            viewRawDataButton.textContent = "View Raw Data";
          }
        } else {
          // Create raw data display
          rawDataDiv = document.createElement("div");
          rawDataDiv.id = "raw-data-display";
          rawDataDiv.className = "raw-data-display";
          rawDataDiv.textContent = JSON.stringify(birthChartData, null, 2);

          // Insert after chat messages
          chatMessages.parentNode.insertBefore(
            rawDataDiv,
            chatMessages.nextSibling
          );
          viewRawDataButton.textContent = "Hide Raw Data";
        }
      });

      function formatBirthChartInfo(birthChart) {
        let info = "";

        // Check for interpretation in various formats (backward compatibility)
        if (birthChart.interpretation) {
          info += birthChart.interpretation;
        } else if (birthChart.interpretationTemplate) {
          info += birthChart.interpretationTemplate;
        } else if (birthChart.deterministicInterpretation) {
          // Format the deterministic interpretation if needed
          info +=
            "Your birth chart has been calculated. Feel free to ask me any questions about it!";
        } else if (birthChart.interpretationError) {
          info += `Error getting interpretation: ${birthChart.interpretationError}`;
        } else {
          // Fallback message if no interpretation is available
          info +=
            "Your birth chart has been calculated. Feel free to ask me any questions about it!";
        }

        return info;
      }

      // Add function to toggle raw chart data visibility
      function toggleRawChartData(button) {
        const container = button.parentElement;
        let rawDataDiv = container.querySelector(".raw-chart-data");

        if (!rawDataDiv) {
          // Create raw data div if it doesn't exist
          rawDataDiv = document.createElement("div");
          rawDataDiv.className = "raw-chart-data";
          rawDataDiv.style.display = "none";

          const birthChart = JSON.parse(button.dataset.chart);
          let rawData = "";

          // Birth Data
          rawData += "Birth Data:\n";
          rawData += `Date: ${birthChart.birthData.date}\n`;
          rawData += `Time: ${birthChart.birthData.time}\n`;
          rawData += `Location: ${birthChart.birthData.location.latitude}Â°N, ${birthChart.birthData.location.longitude}Â°E (UTC${birthChart.birthData.location.timezone})\n\n`;

          // Angular Points
          rawData += "Angular Points:\n";
          rawData += `Ascendant: ${birthChart.angles.ascendant.degree.toFixed(
            2
          )}Â° ${birthChart.angles.ascendant.sign} (${
            birthChart.angles.ascendant.element
          })\n`;
          rawData += `Midheaven: ${birthChart.angles.midheaven.degree.toFixed(
            2
          )}Â° ${birthChart.angles.midheaven.sign} (${
            birthChart.angles.midheaven.element
          })\n\n`;

          // Planetary Positions
          rawData += "Planetary Positions:\n";
          for (const [planet, data] of Object.entries(birthChart.planets)) {
            rawData += `${
              planet.charAt(0).toUpperCase() + planet.slice(1)
            }: ${data.degree.toFixed(2)}Â° ${data.sign} (${data.element})`;
            if (data.isRetrograde) rawData += " â„ž";
            rawData += ` - House ${data.house}\n`;
          }
          rawData += "\n";

          // Houses
          rawData += "Houses:\n";
          birthChart.houses.forEach((house) => {
            rawData += `House ${house.number}: ${house.degree.toFixed(2)}Â° ${
              house.sign
            } (${house.element})\n`;
          });
          rawData += "\n";

          // Aspects
          rawData += "Aspects:\n";
          birthChart.aspects.forEach((aspect) => {
            rawData += `${
              aspect.planet1.charAt(0).toUpperCase() + aspect.planet1.slice(1)
            } ${aspect.aspect} ${
              aspect.planet2.charAt(0).toUpperCase() + aspect.planet2.slice(1)
            } (${aspect.orb.toFixed(2)}Â° orb)\n`;
          });

          rawDataDiv.textContent = rawData;
          container.appendChild(rawDataDiv);
        }

        if (rawDataDiv.style.display === "none") {
          rawDataDiv.style.display = "block";
          button.textContent = "Hide Raw Chart Data";
        } else {
          rawDataDiv.style.display = "none";
          button.textContent = "View Raw Chart Data";
        }
      }

      function showSpinner() {
        const spinnerContainer = document.createElement("div");
        spinnerContainer.className = "spinner-container";

        const spinner = document.createElement("div");
        spinner.className = "spinner";

        const typingIndicator = document.createElement("div");
        typingIndicator.className = "typing-indicator";
        typingIndicator.textContent = "AstroGuide is thinking";

        spinnerContainer.appendChild(spinner);
        spinnerContainer.appendChild(typingIndicator);
        chatMessages.appendChild(spinnerContainer);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      function hideSpinner() {
        const spinnerContainer = document.querySelector(".spinner-container");
        if (spinnerContainer) {
          spinnerContainer.remove();
        }
      }
    </script>
  </body>
</html>
